<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Security+ Lesson 15 – Risk Management</title>
<style>
  :root{
    --ink:#1b1f2f; --muted:#4e566c; --accent:#2463eb; --line:#e2e6ef; --ok:#0b6b2f; --bad:#a5282c; --bg:#ffffff; --hint:#0b6b2f22; --warn:#a5282c22;
  }
  *{box-sizing:border-box}
  body{margin:0; font:16px/1.55 "Segoe UI", Roboto, system-ui, -apple-system, Arial, sans-serif; color:var(--ink); background:var(--bg);}
  header{padding:24px 20px 10px; border-bottom:1px solid var(--line);}
  h1{margin:.2rem 0; font-size:1.4rem;}
  .sub{color:var(--muted);}
  .meta-grid{display:flex; gap:10px; flex-wrap:wrap; margin-top:.5rem;}
  .pill{border:1px solid var(--line); border-radius:999px; padding:.2rem .6rem; color:var(--muted);}
  main{max-width:1000px; margin:0 auto; padding:18px 20px 40px;}
  h2{font-size:1.1rem; color:var(--accent); margin:.3rem 0 .7rem;}
  .card{border:1px solid var(--line); border-radius:12px; padding:16px; margin:16px 0; background:#fff;}
  .controls{display:flex; flex-wrap:wrap; gap:8px; margin:8px 0 0;}
  button{appearance:none; border:1px solid var(--line); background:#fff; padding:.55rem .9rem; border-radius:10px; cursor:pointer; font-weight:600}
  button:hover{border-color:var(--accent)}
  button.primary{background:var(--accent); color:#fff; border-color:var(--accent)}
  button.ghost{background:transparent}

  .q{margin:1rem 0; border:1px solid var(--line); border-radius:12px; padding:14px}
  .q-header{display:flex; align-items:flex-start; justify-content:space-between; gap:8px}
  .q-title{font-weight:600}
  .q-body{margin-top:.5rem}
  .opts{display:grid; gap:.4rem; margin:.6rem 0 0}
  .opt{display:flex; gap:.6rem; align-items:flex-start; padding:.45rem .55rem; border-radius:10px; border:1px solid transparent}
  .opt input{margin-top:.25rem}
  .opt label{display:block; cursor:pointer}
  .q.correct{border-color:var(--ok); background:var(--hint)}
  .q.incorrect{border-color:var(--bad); background:var(--warn)}
  .explain{margin-top:.6rem; font-size:.95rem; color:var(--muted)}
  .akey{color:var(--ok); font-weight:700}
  .scorebar{display:flex; align-items:center; gap:10px;}
  progress{width:240px; height:14px}
  .sr-only{position:absolute; left:-10000px; width:1px; height:1px; overflow:hidden}

  details > summary{cursor:pointer; color:var(--accent); font-weight:600}
  details .akey{display:inline-block; margin-left:.25rem}

  @media print{
    header{border:none}
    button, .controls{display:none !important}
    .q{page-break-inside:avoid}
  }
</style>
</head>
<body>
<header>
  <div class="sub">CompTIA Security+ • Lesson 15</div>
  <h1>Practice / Study Questions — Risk Management Processes</h1>
  <div class="meta-grid">
    <div class="pill">Topic: Risk Management Processes</div>
    <div class="pill" id="qcount">15 Questions</div>
    <div class="pill">Printable</div>
  </div>
</header>


<main>
  <section class="card">
    <h2>Instructions</h2>
    <p>Answer each question, then choose <strong>Check</strong> to see immediate feedback and an explanation. Use <strong>Check All</strong> to grade everything at once, <strong>Shuffle</strong> to change the order (for the 15 currently shown), and <strong>Reset</strong> to load the next set of 15 questions.</p>
    <div class="controls">
      <button class="primary" id="btnCheckAll" type="button" aria-label="Check all questions">Check All</button>
      <button id="btnReset" type="button">Reset (Next 15)</button>
      <button id="btnShuffle" type="button" class="ghost">Shuffle</button>
    </div>
  </section>

  <section id="qs" class="card" aria-live="polite">
    <h2>Questions</h2>
    <div id="qWrap"></div>
  </section>

  <section class="card" id="results" hidden>
    <h2>Results</h2>
    <div class="scorebar">
      <div id="scoreText" aria-live="polite">0 / 15 correct</div>
      <progress id="scoreProg" max="15" value="0" aria-hidden="true"></progress>
    </div>
  </section>

  <section class="card">
    <details>
      <summary>Show answer key</summary>
      <ol id="answerKey"></ol>
    </details>
  </section>
</main>

<script>
// --- Data model (Lesson 8) ---------------------------------------------------
const BANK = [

  {
    q: "What is the primary purpose of the risk management process?",
    options: [
      "To eliminate all organizational risks",
      "To identify, assess, mitigate, and monitor risks to mission-essential functions",
      "To comply with insurance requirements",
      "To focus solely on IT cybersecurity vulnerabilities"
    ],
    a: 1,
    why: "Risk management is a continuous process of identifying, assessing, mitigating, and monitoring risks to protect mission-essential functions.",
    feedback: {
      A: "Risk can never be fully eliminated.",
      C: "Insurance is one tool, not the purpose.",
      D: "Risk management covers operational, financial, physical, and cyber risks—not just IT."
    }
  },

  {
    q: "Which term refers to the level of risk before any controls or mitigation are applied?",
    options: ["Inherent risk", "Residual risk", "Risk appetite", "Risk tolerance"],
    a: 0,
    why: "Inherent risk is the risk level that exists before controls are implemented.",
    feedback: {
      B: "Residual risk is AFTER controls.",
      C: "Risk appetite is how much risk leadership is willing to accept.",
      D: "Risk tolerance describes acceptable variance around the appetite."
    }
  },

  {
    q: "Which term describes the risk level that remains after mitigation, transfer, or acceptance measures have been applied?",
    options: ["Residual risk", "Inherent risk", "Risk posture", "Quantitative risk"],
    a: 0,
    why: "Residual risk remains after security controls or mitigation strategies.",
    feedback: {
      B: "Inherent risk = before mitigation.",
      C: "Risk posture = overall organizational risk status.",
      D: "Quantitative risk refers to numeric models like ALE."
    }
  },

  {
    q: "Which of the following represents a risk response strategy?",
    options: ["Risk triangle", "Risk avoidance", "Risk posture", "Risk indicator"],
    a: 1,
    why: "Avoidance is one of the four risk responses: avoid, mitigate, transfer, accept.",
    feedback: {
      A: "Not a risk response category.",
      C: "Risk posture = overall risk state.",
      D: "Indicators help track risk, not respond to it."
    }
  },

  {
    q: "Cyber insurance is an example of which risk response strategy?",
    options: ["Risk acceptance", "Risk transfer", "Risk avoidance", "Risk reduction"],
    a: 1,
    why: "Insurance shifts some financial consequences to a third party, which is risk transfer.",
    feedback: {
      A: "Acceptance means keeping the risk.",
      C: "Avoidance eliminates the activity entirely.",
      D: "Reduction = mitigation, not transfer."
    }
  },

  {
    q: "Which document captures identified risks, severity, mitigation strategies, ownership, and status?",
    options: ["Risk register", "Asset inventory", "Business continuity plan", "Audit log"],
    a: 0,
    why: "A risk register documents risks, owners, controls, likelihood, and impact.",
    feedback: {
      B: "Asset inventories list assets, not risks.",
      C: "BCP handles operational continuity.",
      D: "Audit logs record system events."
    }
  },

  {
    q: "What is the purpose of a Business Impact Analysis (BIA)?",
    options: [
      "To assess how disruptions affect mission-essential functions",
      "To calculate the organization’s insurance premiums",
      "To identify outdated equipment",
      "To update firewall rules"
    ],
    a: 0,
    why: "A BIA evaluates the impact of disruptions to essential business functions.",
    feedback: {
      B: "Insurance may use risk data but is not the role of a BIA.",
      C: "Equipment is part of asset inventory, not BIA purpose.",
      D: "Firewall rules are unrelated."
    }
  },

  {
    q: "Which metric describes the longest amount of time a business process can be unavailable before irrecoverable failure?",
    options: ["RTO", "RPO", "MTD", "ALE"],
    a: 2,
    why: "Maximum Tolerable Downtime (MTD) is the limit after which mission failure occurs.",
    feedback: {
      A: "RTO = how fast systems must be restored.",
      B: "RPO = acceptable data loss threshold.",
      D: "ALE relates to financial risk."
    }
  },

  {
    q: "Which risk analysis method uses numerical values such as SLE and ARO?",
    options: ["Qualitative analysis", "Quantitative analysis", "Heat mapping", "Peer auditing"],
    a: 1,
    why: "Quantitative analysis expresses risk numerically using SLE, ARO, ALE.",
    feedback: {
      A: "Qualitative uses words (high/medium/low).",
      C: "Heatmaps visualize but do not calculate risk.",
      D: "Audits test controls, not quantify risk."
    }
  },

  {
    q: "Single Loss Expectancy (SLE) is calculated using which formula?",
    options: [
      "SLE = ARO × ALE",
      "SLE = Asset Value × Exposure Factor",
      "SLE = ALE ÷ ARO",
      "SLE = MTD × RTO"
    ],
    a: 1,
    why: "SLE is the financial loss from a single event: asset value × exposure factor.",
    feedback: {
      A: "Incorrect relationship.",
      C: "That's the inverse relationship to find ARO.",
      D: "MTD/RTO are BIA metrics."
    }
  },

  {
    q: "Annualized Loss Expectancy (ALE) is calculated by:",
    options: [
      "ALE = SLE × ARO",
      "ALE = Asset Value × MTD",
      "ALE = SLE ÷ RTO",
      "ALE = Exposure Factor × MTD"
    ],
    a: 0,
    why: "ALE forecasts yearly loss: SLE multiplied by ARO.",
    feedback: {
      B: "Incorrect formula.",
      C: "No relationship between these metrics.",
      D: "Exposure factor deals with SLE."
    }
  },

  {
    q: "Which term describes the overall level of organizational risk based on current threats, vulnerabilities, and controls?",
    options: ["Risk appetite", "Risk posture", "Residual risk", "Control maturity"],
    a: 1,
    why: "Risk posture expresses the organization’s overall risk exposure.",
    feedback: {
      A: "Risk appetite is how much risk leadership accepts.",
      C: "Residual risk is per-item, not organization-wide.",
      D: "Control maturity is about processes."
    }
  },

  {
    q: "What is a Key Risk Indicator (KRI)?",
    options: [
      "A metric that predicts increases in risk exposure",
      "A report listing all open audit findings",
      "A list of all vulnerabilities found in a scan",
      "A list of all mission-essential functions"
    ],
    a: 0,
    why: "KRIs are predictive metrics used to detect emerging risk trends.",
    feedback: {
      B: "Audit findings are separate.",
      C: "A vulnerability list is not a KRI.",
      D: "KRIs do not list functions."
    }
  },

  {
    q: "Which type of risk assessment is performed continuously using automated scanners and monitoring tools?",
    options: [
      "Ad hoc assessment",
      "One-time assessment",
      "Recurring assessment",
      "Continuous assessment"
    ],
    a: 3,
    why: "Continuous assessments evaluate risks in real time using automated tools.",
    feedback: {
      A: "Ad hoc = triggered by events.",
      B: "One-time = specific point in time.",
      C: "Recurring = periodic, not continuous."
    }
  },

  {
    q: "Which step in the risk management process involves determining threats that may exploit vulnerabilities?",
    options: [
      "Identify mission-essential functions",
      "Identify vulnerabilities",
      "Identify threats",
      "Identify risk response"
    ],
    a: 2,
    why: "Threat identification catalogs actors and conditions that may exploit vulnerabilities.",
    feedback: {
      A: "This occurs first, but unrelated.",
      B: "Vulnerabilities describe weaknesses, not threats.",
      D: "Responses are chosen after analysis."
    }
  }

];


// --- State / Paging ----------------------------------------------------------
const PAGE_SIZE = 15;          // always show 15 questions
let cycleIndex = 0;            // advances by 15 on each Reset

let QUESTIONS = [];
const qWrap = document.getElementById('qWrap');
const results = document.getElementById('results');
const scoreText = document.getElementById('scoreText');
const scoreProg = document.getElementById('scoreProg');
const answerKey = document.getElementById('answerKey');
const qcount = document.getElementById('qcount');

function shuffle(arr){
  for(let i=arr.length-1;i>0;i--){
    const j = Math.floor(Math.random()*(i+1));
    [arr[i],arr[j]] = [arr[j],arr[i]];
  }
  return arr;
}

// slice 15, with wraparound if needed
function getSlice(start, size){
  const total = BANK.length;
  const out = [];
  for(let i=0;i<size;i++){
    out.push(BANK[(start + i) % total]);
  }
  return out;
}

function reset(){
  QUESTIONS = getSlice(cycleIndex, PAGE_SIZE).map((q, idx) => ({...q, id: idx+1}));
  cycleIndex = (cycleIndex + PAGE_SIZE) % BANK.length; // advance to next “page” for next Reset
  render();
  results.hidden = true;
  scoreProg.max = QUESTIONS.length;
  qcount.textContent = `${QUESTIONS.length} Questions`;
}

function render(){
  qWrap.innerHTML = '';
  answerKey.innerHTML = '';
  QUESTIONS.forEach((q, qi) => {
    const card = document.createElement('article');
    card.className = 'q';
    card.id = `q${qi+1}`;

    const head = document.createElement('div');
    head.className = 'q-header';
    head.innerHTML = `<div class="q-title">${qi+1}. ${q.q}</div>`;

    const body = document.createElement('div');
    body.className = 'q-body';

    const opts = document.createElement('div');
    opts.className = 'opts';

    q.options.forEach((txt, oi) => {
      const id = `q${qi}_opt${oi}`;
      const row = document.createElement('div');
      row.className = 'opt';

      const input = document.createElement('input');
      input.type = 'radio';
      input.name = `q${qi}`;
      input.id = id;
      input.value = oi;

      const label = document.createElement('label');
      label.setAttribute('for', id);
      label.innerHTML = `<strong>${String.fromCharCode(65+oi)}.</strong> ${txt}`;

      row.appendChild(input); row.appendChild(label);
      opts.appendChild(row);
    });

    const ctrls = document.createElement('div');
    ctrls.className = 'controls';
    const btnCheck = document.createElement('button');
    btnCheck.textContent = 'Check';
    btnCheck.type = 'button';
    btnCheck.addEventListener('click', () => gradeOne(qi));

    const btnClear = document.createElement('button');
    btnClear.textContent = 'Clear';
    btnClear.type = 'button';
    btnClear.className = 'ghost';
    btnClear.addEventListener('click', () => clearOne(qi));

    const fb = document.createElement('div');
    fb.className = 'explain';
    fb.id = `fb${qi}`;

    ctrls.appendChild(btnCheck); ctrls.appendChild(btnClear);
    body.appendChild(opts);
    body.appendChild(ctrls);
    body.appendChild(fb);

    card.appendChild(head);
    card.appendChild(body);
    qWrap.appendChild(card);

    const li = document.createElement('li');
    li.innerHTML = `<span class="akey">${String.fromCharCode(65+q.a)}</span> – ${q.options[q.a]}`;
    answerKey.appendChild(li);
  });
}

function getChoice(qi){
  const sel = document.querySelector(`input[name="q${qi}"]:checked`);
  return sel ? parseInt(sel.value,10) : null;
}

function gradeOne(qi){
  const q = QUESTIONS[qi];
  const choice = getChoice(qi);
  const card = document.getElementById(`q${qi+1}`);
  const fb = document.getElementById(`fb${qi}`);
  card.classList.remove('correct','incorrect');

  if(choice === null){
    fb.innerHTML = '<em>Please select an option.</em>';
    return;
  }
  const isCorrect = choice === q.a;
  card.classList.add(isCorrect ? 'correct' : 'incorrect');
  const your = String.fromCharCode(65+choice);
  const key = String.fromCharCode(65+q.a);

  let extra = '';
  if(!isCorrect && q.feedback){
    extra = q.feedback[your] ? `<br><em>${q.feedback[your]}</em>` : '';
  }

  fb.innerHTML = `${isCorrect ? '✅ Correct' : '❌ Incorrect'} — Your answer: <strong>${your}</strong>. Correct answer: <strong class="akey">${key}</strong>.
    <br>${q.why}${extra}`;
  updateScore();
}

function clearOne(qi){
  const card = document.getElementById(`q${qi+1}`);
  const fb = document.getElementById(`fb${qi}`);
  card.classList.remove('correct','incorrect');
  fb.textContent='';
  const radios = document.querySelectorAll(`input[name="q${qi}"]`);
  radios.forEach(r=> r.checked=false);
  updateScore();
}

function updateScore(){
  let correct = 0;
  QUESTIONS.forEach((q, qi)=>{
    const sel = getChoice(qi);
    if(sel !== null && sel === q.a) correct++;
  });
  scoreText.textContent = `${correct} / ${QUESTIONS.length} correct`;
  scoreProg.value = correct;
  results.hidden = false;
}

function gradeAll(){
  QUESTIONS.forEach((_, qi) => gradeOne(qi));
}

// --- Top controls ------------------------------------------------------------
document.getElementById('btnCheckAll').addEventListener('click', gradeAll);
document.getElementById('btnReset').addEventListener('click', reset);
document.getElementById('btnShuffle').addEventListener('click', ()=>{
  QUESTIONS = shuffle(QUESTIONS);
  render();
});

// Init
reset();
</script>
</body>
</html>
